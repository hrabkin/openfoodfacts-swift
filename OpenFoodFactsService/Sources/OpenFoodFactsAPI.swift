// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// As a developer, the Open Food Facts API allows you to get information
/// and contribute to the products database. You can create great apps to
/// help people make better food choices and also provide data to enhance the database.
///
public struct OpenFoodFactsAPI: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get information for a specific product by barcode
    ///
    /// A product can be fetched via its unique barcode.
    /// It returns all the details of that product response.
    ///
    ///
    /// - Remark: HTTP `GET /api/v2/product/{barcode}`.
    /// - Remark: Generated from `#/paths//api/v2/product/{barcode}/get(getProductByBarcode)`.
    public func getProductByBarcode(_ input: Operations.getProductByBarcode.Input) async throws -> Operations.getProductByBarcode.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProductByBarcode.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v2/product/{}",
                    parameters: [
                        input.path.barcode
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProductByBarcode.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.get_product_by_barcode.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Knowledge panels for a specific product by barcode
    /// (special case of get product)
    ///
    ///
    /// Knowledge panels gives high leve informations about a product,
    /// ready to display.
    /// This is used by open food facts website,
    /// and by the official mobile application
    ///
    ///
    /// - Remark: HTTP `GET /api/v2/product/{barcode}?fields=knowledge_panels`.
    /// - Remark: Generated from `#/paths//api/v2/product/{barcode}?fields=knowledge_panels/get(getProductByBarcodeKnowledgePanels)`.
    public func getProductByBarcodeKnowledgePanels(_ input: Operations.getProductByBarcodeKnowledgePanels.Input) async throws -> Operations.getProductByBarcodeKnowledgePanels.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProductByBarcodeKnowledgePanels.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v2/product/{}?fields=knowledge_panels",
                    parameters: [
                        input.path.barcode
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProductByBarcodeKnowledgePanels.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getProductByBarcodeKnowledgePanels.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Performing OCR on a Product
    ///
    /// Open Food Facts uses optical character recognition (OCR) to retrieve nutritional data and other information from the product labels.
    ///
    ///
    /// - Remark: HTTP `GET /cgi/ingredients.pl`.
    /// - Remark: Generated from `#/paths//cgi/ingredients.pl/get(getIngredients)`.
    public func getIngredients(_ input: Operations.getIngredients.Input) async throws -> Operations.getIngredients.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getIngredients.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/ingredients.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "id",
                    value: input.query.id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "code",
                    value: input.query.code
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "process_image",
                    value: input.query.process_image
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ocr_engine",
                    value: input.query.ocr_engine
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getIngredients.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ocr_on_product.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Rotate A Photo
    ///
    /// Although we recommend rotating photos manually and uploading a new version of the image,
    /// the OFF API allows you to make api calls to automate this process.
    /// You can rotate existing photos by setting the angle to 90º, 180º, or 270º clockwise.
    ///
    ///
    /// - Remark: HTTP `GET /cgi/product_image_crop.pl`.
    /// - Remark: Generated from `#/paths//cgi/product_image_crop.pl/get(getProductImageCrop)`.
    public func getProductImageCrop(_ input: Operations.getProductImageCrop.Input) async throws -> Operations.getProductImageCrop.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProductImageCrop.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/product_image_crop.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "code",
                    value: input.query.code
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "id",
                    value: input.query.id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "imgid",
                    value: input.query.imgid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "angle",
                    value: input.query.angle
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProductImageCrop.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.rotate_a_photo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Crop A Photo
    ///
    /// Cropping is only relevant for editing existing products.
    /// You cannot crop an image the first time you upload it to the system.
    ///
    ///
    /// - Remark: HTTP `POST /cgi/product_image_crop.pl`.
    /// - Remark: Generated from `#/paths//cgi/product_image_crop.pl/post(productImageCrop)`.
    public func productImageCrop(_ input: Operations.productImageCrop.Input) async throws -> Operations.productImageCrop.Output {
        try await client.send(
            input: input,
            forOperation: Operations.productImageCrop.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/product_image_crop.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "code",
                            "id",
                            "imgid"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "angle",
                            "normalize",
                            "white_magic",
                            "x1",
                            "x2",
                            "y1",
                            "y2"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .imgid(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "imgid",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .x1(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "x1",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .y1(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "y1",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .x2(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "x2",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .y2(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "y2",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .angle(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "angle",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .normalize(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "normalize",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .white_magic(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "white_magic",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.productImageCrop.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIObjectContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unselect A Photo
    ///
    /// - Remark: HTTP `POST /cgi/product_image_unselect.pl`.
    /// - Remark: Generated from `#/paths//cgi/product_image_unselect.pl/post(postProductImageUnselect)`.
    public func postProductImageUnselect(_ input: Operations.postProductImageUnselect.Input) async throws -> Operations.postProductImageUnselect.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postProductImageUnselect.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/product_image_unselect.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "code",
                            "id"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postProductImageUnselect.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.postProductImageUnselect.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add or Edit A Product
    ///
    /// This updates a product.
    ///
    /// Note: If the barcode exists then you will be editing the existing product,
    /// However if it doesn''t you will be creating a new product with that unique barcode,
    /// and adding properties to the product.
    ///
    ///
    /// - Remark: HTTP `POST /cgi/product_jqm2.pl`.
    /// - Remark: Generated from `#/paths//cgi/product_jqm2.pl/post(postProduct)`.
    public func postProduct(_ input: Operations.postProduct.Input) async throws -> Operations.postProduct.Output {
        try await client.send(
            input: input,
            forOperation: Operations.postProduct.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/product_jqm2.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "code",
                            "imagefield",
                            "password",
                            "user_id"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "app_name",
                            "app_uuid",
                            "app_version",
                            "comment",
                            "packaging",
                            "user_agent"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "brands",
                            "categories",
                            "labels"
                        ],
                        encoding: { part in
                            switch part {
                            case let .code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .user_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "user_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .password(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "password",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .comment(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "comment",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .brands(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "brands",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .labels(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "labels",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .categories(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "categories",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .packaging(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "packaging",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .app_name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "app_name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .app_version(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "app_version",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .app_uuid(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "app_uuid",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .user_agent(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "user_agent",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .imagefield(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsJSON(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/json; charset=utf-8"
                                )
                                return .init(
                                    name: "imagefield",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.postProduct.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.add_or_edit_a_product.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search for Products
    ///
    /// Search request allows you to get products that match your search criteria.
    ///
    /// It allows you create many custom APIs for your use case.
    ///
    /// If the search query parameter has 2 possible values, they are seperated by a comma(,).
    /// When filtering via a parameter that has different language codes like `fr`, `de` or `en`, specify the language code in the parameter name e.g `categories_tags_en`
    ///
    /// **Important:** search API v2 does not support full text request (search_term),
    /// you have to use [search API v1](https://wiki.openfoodfacts.org/API/Read/Search) for that.
    /// Upcoming [search-a-licious project](https://github.com/openfoodfacts/search-a-licious) will fix that.
    ///
    /// ### Limiting results
    ///
    /// You can limit the size of returned objects thanks to the `fields` object (see below).
    ///
    /// eg: `fields=code,product_name,brands,attribute_groups``
    ///
    /// Please use it as much as possible to avoid overloading the servers.
    ///
    /// The search use pagination, see `page` and `page_size` parameters.
    ///
    /// **Beware:** the `page_count` data in item is a bit counter intuitive…, read the description.
    ///
    /// ### Conditions on tags
    ///
    /// All `_tags`` parameters accepts either:
    ///
    /// * a single value
    /// * or a comma-separated list of values (doing a AND)
    /// * or a pipe separated list of values (doing a OR)
    ///
    /// You can exclude terms by using a "-" prefix.
    ///
    /// For taxonomized entries, you might either use the tag id (recommended),
    /// or a known synonym (without language prefix)
    ///
    /// * `labels_tags=en:organic,en:fair-trade` find items that are fair-trade AND organic
    /// * `labels_tags=en:organic|en:fair-trade` find items that are fair-trade OR organic
    /// * `labels_tags=en:organic,en:-fair-trade` find items that are organic BUT NOT fair-trade
    ///
    ///
    /// ### Conditions on nutriments
    ///
    /// To get a list of nutrients
    ///
    /// You can either query on nutrient per 100g (`_100g` suffix)
    /// or per serving (`serving` suffix).
    ///
    /// You can also add `_prepared_`
    /// to get the nutrients in the prepared product instead of as sold.
    ///
    /// You can add a comparison operator and value to the parameter name
    /// to get products with nutrient above or bellow a value.
    /// If you use a parameter value it exactly match it.
    ///
    /// * `energy-kj_100g<200` products where energy in kj for 100g is less than 200kj
    /// * `sugars_serving>10` products where sugar per serving is greater than 10g
    /// * `saturated-fat_100g=1` products where saturated fat per 100g is exactly 10g
    /// * `salt_prepared_serving<0.1` products where salt per serving for prepared product is less than 0.1g
    ///
    /// ### More references
    ///
    /// See also [wiki page](https://wiki.openfoodfacts.org/Open_Food_Facts_Search_API_Version_2)
    ///
    ///
    /// - Remark: HTTP `GET /api/v2/search`.
    /// - Remark: Generated from `#/paths//api/v2/search/get(searchProducts)`.
    public func searchProducts(_ input: Operations.searchProducts.Input) async throws -> Operations.searchProducts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.searchProducts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v2/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "additives_tags",
                    value: input.query.additives_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "allergens_tags",
                    value: input.query.allergens_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "brands_tags",
                    value: input.query.brands_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "categories_tags",
                    value: input.query.categories_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "countries_tags_en",
                    value: input.query.countries_tags_en
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "emb_codes_tags",
                    value: input.query.emb_codes_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "labels_tags",
                    value: input.query.labels_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "manufacturing_places_tags",
                    value: input.query.manufacturing_places_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "nutrition_grades_tags",
                    value: input.query.nutrition_grades_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "origins_tags",
                    value: input.query.origins_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "packaging_tags_de",
                    value: input.query.packaging_tags_de
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "purchase_places_tags",
                    value: input.query.purchase_places_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "states_tags",
                    value: input.query.states_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "stores_tags",
                    value: input.query.stores_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "traces_tags",
                    value: input.query.traces_tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "<tag_name>_tags_<language_code>",
                    value: input.query._lt_tag_name_gt__tags__lt_language_code_gt_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "<nutrient>_lt_<value>",
                    value: input.query._lt_nutrient_gt__lt__lt_value_gt_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "<nutrient>_gt_<value>",
                    value: input.query._lt_nutrient_gt__gt__lt_value_gt_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "<nutrient>_eq_<value>",
                    value: input.query._lt_nutrient_gt__eq__lt_value_gt_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fields",
                    value: input.query.fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort_by",
                    value: input.query.sort_by
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.searchProducts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.search_for_products.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Suggestions to Aid Adding/Editing Products
    ///
    /// For example , Dave is looking for packaging_shapes that contain the term "fe",
    /// all packaging_shapes containing "fe" will be returned.
    /// This is useful if you have a search in your application,
    /// for a specific product field.
    ///
    ///
    /// - Remark: HTTP `GET /cgi/suggest.pl`.
    /// - Remark: Generated from `#/paths//cgi/suggest.pl/get(getSuggestions)`.
    public func getSuggestions(_ input: Operations.getSuggestions.Input) async throws -> Operations.getSuggestions.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSuggestions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/suggest.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tagtype",
                    value: input.query.tagtype
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "term",
                    value: input.query.term
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSuggestions.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIArrayContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a nested list of nutrients that can be displayed in the nutrition facts table for a specific country and language
    ///
    /// Used to display the nutrition facts table of a product, or to display a form to input those nutrition facts.
    ///
    ///
    /// - Remark: HTTP `GET /cgi/nutrients.pl`.
    /// - Remark: Generated from `#/paths//cgi/nutrients.pl/get(getNutrients)`.
    public func getNutrients(_ input: Operations.getNutrients.Input) async throws -> Operations.getNutrients.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getNutrients.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/cgi/nutrients.pl",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cc",
                    value: input.query.cc
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lc",
                    value: input.query.lc
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNutrients.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.get_nutrients.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the list of attributes available for personal search.
    ///
    /// Attributes are at the heart of personal search.
    /// They score the products according to different criterias,
    /// which could then be matched to a user's preferences.
    ///
    /// This API helps you list attributes and display them in your application,
    /// for the user to choose the importance of each criteria.
    ///
    /// note: /api/v2/attribute_groups_{lc} is also a valid route, but consider it deprecated
    ///
    ///
    /// - Remark: HTTP `GET /api/v2/attribute_groups`.
    /// - Remark: Generated from `#/paths//api/v2/attribute_groups/get(getAttributeGroups)`.
    public func getAttributeGroups(_ input: Operations.getAttributeGroups.Input) async throws -> Operations.getAttributeGroups.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAttributeGroups.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v2/attribute_groups",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lc",
                    value: input.query.lc
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAttributeGroups.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.get_attribute_groups.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the weights corresponding to attributes preferences
    /// to compute personal product
    ///
    ///
    /// - Remark: HTTP `GET /api/v2/preferences`.
    /// - Remark: Generated from `#/paths//api/v2/preferences/get(getPreferences)`.
    public func getPreferences(_ input: Operations.getPreferences.Input) async throws -> Operations.getPreferences.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getPreferences.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/v2/preferences",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lc",
                    value: input.query.lc
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getPreferences.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.get_preferences.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
